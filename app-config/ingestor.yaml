# Ingestor Plugin Configuration
# The ingestor plugin discovers and imports Kubernetes resources into the Backstage catalog

# Ingestor configuration
ingestor:
  # ============================================================================
  # Entity Organization Mappings
  # ============================================================================
  # Controls how Backstage entities are organized and grouped for ALL ingested
  # Kubernetes resources, including:
  # - Standard K8s resources (Deployments, Services, etc.)
  # - Crossplane Claims (v1 style with spec.resourceRef)
  # - Crossplane XRs (v2 style with spec.crossplane)
  #
  # These mappings control the Backstage entity namespace and system fields,
  # which determine how entities are grouped and filtered in the catalog UI.
  # ============================================================================
  mappings:
    # Entity Namespace Mapping
    # Controls the Backstage entity's metadata.namespace field
    # This determines entity isolation and access control
    #
    # Options:
    #   'cluster'   - Group by K8s cluster (e.g., entities in namespace "production-cluster")
    #   'namespace' - Group by K8s namespace (e.g., entities in namespace "backend-team")
    #   'default'   - All entities in default namespace (flat structure)
    #
    # Example: With 'cluster', a Pod in cluster "prod" goes to Backstage namespace "prod"
    # Example: With 'namespace', a Pod in K8s namespace "api" goes to Backstage namespace "api"
    namespaceModel: 'namespace'

    # System Name Mapping
    # Controls the Backstage entity's spec.system field reference
    # This determines how components are grouped into systems in the catalog
    #
    # Options:
    #   'cluster'           - System name is the cluster name (e.g., "system:rancher-desktop")
    #   'namespace'         - System name is the K8s namespace (e.g., "system:demo")
    #   'cluster-namespace' - System name combines both (e.g., "system:prod-backend")
    #   'default'           - All components belong to "system:default"
    #
    # Example: With 'cluster', all resources from "prod" cluster belong to "system:prod"
    # Example: With 'cluster-namespace', resources from "prod" cluster in "api" namespace
    #          belong to "system:prod-api"
    systemModel: 'cluster'

    # Entity Name Mapping
    # Controls the Backstage entity's metadata.name field format
    # This determines the unique identifier for each entity
    #
    # Options:
    #   'name'                   - Just the resource name (e.g., "payment-service")
    #   'name-cluster'           - Name + cluster (e.g., "payment-service-prod")
    #   'name-namespace'         - Name + namespace (e.g., "payment-service-backend")
    #   'name-namespace-cluster' - Name + namespace + cluster (e.g., "payment-service-backend-prod")
    #
    # Example: With 'name-cluster', a deployment "api" in cluster "prod" becomes "api-prod"
    # Example: With 'name-namespace-cluster', it becomes "api-default-prod"
    #
    # NOTE: Choose wisely! Shorter names are cleaner but may conflict across namespaces/clusters.
    #       Longer names are unique but verbose. Consider your multi-cluster setup.
    nameModel: 'name-namespace-cluster'

    # Entity Title Mapping
    # Controls automatic title generation when no backstage.io/title annotation exists
    # Annotations always take precedence over titleModel when present
    #
    # Options:
    #   'name'              - Just the resource name (e.g., "payment-service")
    #   'name-cluster'      - Name with cluster (e.g., "payment-service (prod)")
    #   'name-namespace'    - Name with namespace (e.g., "payment-service (backend)")
    #   'kind-name'         - Kind prefix (e.g., "Deployment: payment-service")
    #   'kind-name-cluster' - Kind + name + cluster (e.g., "Deployment: payment-service (prod)")
    #
    # Example: With 'kind-name-cluster', a Deployment "api" in "prod" shows as "Deployment: api (prod)"
    # Example: With 'name', resources show with their simple name as the title
    #
    # NOTE: Default is 'name' for clean, simple titles. Use other models for more context.
    #       Teams can always override with backstage.io/title annotations on resources.
    titleModel: 'name'

  # Kubernetes resource ingestion (includes Claims and XRs via auto-detection)
  kubernetes:
    enabled: true
    taskRunner:
      frequency: 20  # How often to query clusters (in seconds)
      timeout: 600   # Max processing time
    excludedNamespaces:
      - kube-public
      - kube-system
      - kube-node-lease
      - flux-system
      - crossplane-system
      - backstage-system
      - calico-system
      - calico-apiserver
      - tigera-operator
      - ingress-nginx
      - external-dns
      - cert-manager
      - kubernetes-dashboard

  # Crossplane XRD template generation
  crossplane:
    enabled: true
    xrds:
      enabled: true
      ingestAllXRDs: true  # Ingest all XRDs with the label
      # Only ingest XRDs with this label (if ingestAllXRDs is false)
      # labelSelector: 'openportal.dev/add-to-catalog'

      # Custom template directory (optional)
      # If not specified, uses built-in templates from npm package
      # Initialize custom templates with: yarn ingestor:init
      templateDir: './ingestor-templates'

      taskRunner:
        frequency: 20  # How often to regenerate templates from XRDs (in seconds)
        timeout: 600   # Max processing time

      # GitOps configuration for template generation
      gitops:
        # Repository where XR instances are created via PRs
        owner: 'open-service-portal'
        repo: 'catalog-orders'
        targetBranch: 'main'
